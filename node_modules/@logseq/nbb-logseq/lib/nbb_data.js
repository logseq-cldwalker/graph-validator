
import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
'use strict';var YDa=new $APP.r(null,"diff","diff",-518492986,null),ZDa=new $APP.r("clojure.data","diff","clojure.data/diff",-683865998,null);var $Da=$APP.Px($APP.jJ),aEa=new $APP.h(null,1,[YDa,function(){var a=new $APP.zd(function(){return $APP.Yy},ZDa,$APP.Ij([$APP.R,$APP.Q,$APP.mo,$APP.rC,$APP.rp,$APP.no,$APP.sC,$APP.T,$APP.W,$APP.tC],[$APP.jJ,YDa,"clojure/data.cljs",11,1,144,144,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.HF,$APP.DF],null)),"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.",
$APP.k($APP.Yy)?$APP.Yy.A:null])),b=$APP.p(a);a=$APP.we(a);var c=$APP.k(null)?null:$APP.Q.g(a),d=new $APP.h(null,4,[$APP.R,$Da,$APP.Q,c,$APP.T,$APP.T.g(a),$APP.W,$APP.W.g(a)],null);return $APP.k($APP.Or.g(a))?$APP.Kx(c,b,d):$APP.k($APP.xs.g(a))?$APP.Lx(c,b,d):$APP.Jx(c,b,d)}()],null);try{$APP.Gy(new $APP.h(null,1,[$APP.qs,new $APP.h(null,1,[$APP.jJ,aEa],null)],null))}catch(a){throw console.error("An error occurred when calling (nbb.impl.data/init)"),a;};
export { $APP, shadow$provide, $jscomp };
